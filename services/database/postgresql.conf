# postgresql.conf - Silvasonic Optimized Configuration
# Target Hardware: Raspberry Pi 5 (4GB/8GB) with NVMe Storage
# PostgreSQL 17 + TimescaleDB 2.19

# ==============================================================================
# CONNECTION & AUTHENTICATION
# ==============================================================================
listen_addresses = '*'
max_connections = 100

# ==============================================================================
# MEMORY (Conservative — leave RAM for Audio Buffers & TFLite)
# ==============================================================================
shared_buffers = 512MB                  # ~12% of 4GB (conservative, avoids OOM)
effective_cache_size = 1536MB           # Query planner hint (OS file cache estimate)
work_mem = 8MB                          # Per-sort/hash operation (100 conns × 8MB = 800MB worst case)
maintenance_work_mem = 128MB            # VACUUM, CREATE INDEX, TimescaleDB compression
huge_pages = off                        # Pi 5 does not configure huge pages

# ==============================================================================
# NVMe OPTIMIZATIONS (Write Throughput & Flash Lifespan)
# ==============================================================================
# NVMe random I/O is nearly as fast as sequential
random_page_cost = 1.1
effective_io_concurrency = 200          # NVMe can handle many concurrent I/O ops (default: 1)

# Asynchronous Commits:
# RISK: May lose < 1s of data on catastrophic power loss.
# GAIN: Massive write throughput for high-frequency bioacoustic metadata.
synchronous_commit = off
wal_writer_delay = 200ms

# Checkpointing (reduce write amplification on flash storage)
checkpoint_timeout = 15min
max_wal_size = 2GB
checkpoint_completion_target = 0.9      # PG17 default, explicit for clarity

# WAL Compression (lz4 is faster than pglz with minimal CPU on Pi 5)
wal_compression = lz4

# ==============================================================================
# PARALLELISM (Pi 5 = 4 cores, must share with audio recording)
# ==============================================================================
max_worker_processes = 24               # TimescaleDB needs: 1 + bg_workers + parallel_workers
max_parallel_workers = 2                # Conservative: leave cores for recorder service
max_parallel_workers_per_gather = 1     # Max 1 parallel worker per query

# ==============================================================================
# TIMESCALEDB
# ==============================================================================
shared_preload_libraries = 'timescaledb'
timescaledb.max_background_workers = 16 # Compression, retention, continuous aggregates

# ==============================================================================
# LOGGING & LOCALE
# ==============================================================================
timezone = 'UTC'
log_timezone = 'UTC'
log_destination = 'stderr'              # Container-friendly (captured by podman)
logging_collector = off                 # Not needed in containers (stdout/stderr → compose logs)
log_line_prefix = '%m [%p] %q%u@%d '
log_min_duration_statement = 1000       # Log queries slower than 1s
